#!@PERL@ -w

#  GNOME PO Update Utility.
#  (C) 2000 The Free Software Foundation
#
#  Author(s): Kenneth Christiansen
#
#  GNOME PO Update Utility can use the XML to POT Generator, xml-i18n-extract
#  Please distribute it along with this scrips, aswell as desk.po and
#  README.tools.
#
#  Also remember to change $PACKAGE to reflect the package the script is
#  used within.


## Declare global variables
my $PROGRAM  = "xml-i18n-update";
my $VERSION  = "@VERSION@";
my $_PACKAGE = "@PACKAGE@";

my $LANG     = $ARGV[0];

my @languages;
my %po_files_by_lang = ();

my $PACKAGE = &find_package_name;

## Always print as the first thing
$| = 1;

## Give error if script is run without an argument
if (! $LANG){
    print "${PROGRAM}:  missing file arguments\n";
    print "Try `${PROGRAM} --help' for more information.\n";
    exit;
}

## Use the supplied arguments
if ($LANG=~/^-(.)*/){

    if ("$LANG" eq "--version" || "$LANG" eq "-V")
    {
        &version;
    }
    elsif ($LANG eq "--help" || "$LANG" eq "-H")
    {
	&help;
    }
    elsif ($LANG eq "--dist" || "$LANG" eq "-D")
    {
        &merging;
	&status;
    }
    elsif ($LANG eq "--pot" || "$LANG" eq "-P")
    {
        &gen_headers;
        exit;
    }
    elsif ($LANG eq "--headers"  || "$LANG" eq "-S")
    {
        &gen_headers;
        exit;
    }
    elsif ($LANG eq "--maintain" || "$LANG" eq "-M")
    {
        &maintain;
    }
    elsif ($LANG eq "--statuslist" || "$LANG" eq "-L")
    {
	&show_status;
    }
    else {
        &invalid_option;
    }

} else {
   
   ## Run standard procedure
   if(-s "$LANG.po"){
        &gen_headers; 
	&generate_pot;
	&merging;
	&status;
   }  

   ## Report error if the language file supplied
   ## to the command line is non-existent
   else {
	&not_existing;       
   }
}

sub version{

    ## Print version information
    print "${PROGRAM} ${_PACKAGE} $VERSION\n";
    print "Written by Kenneth Christiansen <kenneth\@gnome.org>, 2000.\n\n";
    print "Copyright (C) 2000 Free Software Foundation, Inc.\n";
    print "This is free software; see the source for copying conditions.  There is NO\n";
    print "warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n";
    exit;
}

sub help
{
    ## Print usage information
    print "Usage: ./${PROGRAM} [OPTIONS] ...LANGCODE\n";
    print "Updates pot files and merge them with the translations.\n\n";
    print "  -H, --help                   shows this help page\n";
    print "  -P, --pot                    generate the pot file only\n";
    print "  -S, --headers                generate the XML headerfiles in POTFILES.in\n";
    print "  -M, --maintain               search for missing files in POTFILES.in\n";
    print "  -L, --statuslist		  creates a statusreport for the module.\n";
    print "  -V, --version                shows the version\n";
    print "\nExamples of use:\n";
    print "update.sh --pot    just creates a new pot file from the source\n";
    print "update.sh da       created new pot file and updated the da.po file\n\n";
    print "Report bugs to <kenneth\@gnome.org>.\n";
    exit;
}

sub maintain
{   
    ## Search and find all translatable files
    $list_i18n_plain = "find ../ -print | egrep '.*\\.(c|y|cc|c++|h|gob)\$' ";
    $list_i18n_xml   = "find ../ -print | egrep '.*\\.(xml|glade|oaf\.in)\$' ";

    open(BUF3, "POTFILES.in") || die "${PROGRAM}:  there's no POTFILES.in!!!\n";
    
    print "Searching for missing translatable files...\n";
    
    open(BUF1, "$list_i18n_plain|");
    open(BUF2, "$list_i18n_xml|");

    @buf_i18n_plain 	= <BUF1>;
    @buf_i18n_xml 	= <BUF2>;
    @buf_potfiles	= <BUF3>;

    ## Check if we should ignore some found files, when 
    ## comparing with POTFILES.in
    if (-s "POTFILES.skip"){
        open FILE, "POTFILES.skip";
        while (<FILE>) {
            if ($_=~/^[^#]/o){
                push @buf_potfiles_ignore, $_;
            }
        }
        print "Found POTFILES.skip: Ignoring files...\n";
        @buf_potfiles = (@buf_potfiles_ignore, @buf_potfiles);
    }

    foreach my $file (@buf_i18n_plain){
        open FILE, "<$file";
        while (<FILE>) {
            if ($_=~/_\(\"/o){
                $file = unpack("x3 A*",$file) . "\n";
                push @buf_allfiles, $file;
                last;
            }
        }
    }

    foreach my $file (@buf_i18n_xml){ 
        open FILE, "<$file";
        while (<FILE>) {
            if ($_=~/\s_(.*)\=\"/o){
                $file = unpack("x3 A*",$file) . "\n";
                push @buf_allfiles, $file;
                last;
            }
        }
    }

    @buf_allfiles_sorted = sort (@buf_allfiles);
    @buf_potfiles_sorted = sort (@buf_potfiles);

    my %in2;
    foreach (@buf_potfiles_sorted) {
        $in2{$_} = 1;
    }

    foreach (@buf_allfiles_sorted){
        if (!exists($in2{$_})){
            push @result, $_ 
        }
    }

    ## Save file with information about the files missing
    ## if any, and give information about this proceedier
    if(@result){
        open OUT, ">missing";
        print OUT @result;
        print "\nHere is the result:\n\n", @result, "\n";
        print "The file \"missing\" has been placed in the current directory.\n";
        print "Files supposed to be ignored should be placed in \"POTFILES.skip\"\n";
    }

    ## If there is nothing to complain about, notice the user
    else{
        print "\nWell, it's all perfect! Congratulation!\n";
    }         
}

sub invalid_option
{
    ## Handle invalid arguments
    print "${PROGRAM}: invalid option -- $LANG\n";
    print "Try `${PROGRAM} --help' for more information.\n";
}
 
sub gen_headers
{
    my $XML_I18N_EXTRACT = `which xml-i18n-extract 2>/dev/null`;
    chomp $XML_I18N_EXTRACT;
 
    $XML_I18N_EXTRACT = $ENV{"XML_I18N_EXTRACT"} if $ENV{"XML_I18N_EXTRACT"};
 
    ## Generate the .h header files, so we can allow glade and
    ## xml translation support
    if (! -s $XML_I18N_EXTRACT)
    {
	print "\n *** The xml-i18n-extract script wasn't found!"
	     ."\n *** Without this xml-i18n-update might not generate correct files.";
	exit;
    } 
    else 
    {
        open FILE, "<POTFILES.in";
        while (<FILE>) {

           ## Find .xml.h files in POTFILES.in and generate the
           ## files with help from the xml-i18n-extract script

           if ($_=~ /(.*)(\.xml)/o){
              $filename = "../$1.xml";
              system($XML_I18N_EXTRACT, "--update", $filename);
           }
      
           ## Find .glade.h files in POTFILES.in and generate
           ## the files with help from the xml-i18n-extract script

           elsif ($_=~ /(.*)(\.glade)/o){
              $filename = "../$1.glade";
              $xmlfiles="$XML_I18N_EXTRACT --update $filename";
              system($XML_I18N_EXTRACT, "--update", $filename);
           }

           ## Find .oaf.in.h files in POTFILES.in and generate
           ## the files with help from the xml-i18n-extract script

           elsif ($_=~ /(.*)(\.oaf\.in)/o){
              $filename = "../$1.oaf.in";
              $xmlfiles="$XML_I18N_EXTRACT --update $filename";
              system($XML_I18N_EXTRACT, "--update", $filename);
           }
       }
       close FILE;
   }
}

sub generate_pot
{
    ## Generate the potfiles from the POTFILES.in file

    print "Building the $PACKAGE.pot...\n";

    system ("mv POTFILES.in POTFILES.in.old");    

    open INFILE, "<POTFILES.in.old";
    open OUTFILE, ">POTFILES.in";
    while (<INFILE>) {
        s/\.glade$/\.glade\.h/;
        s/\.xml$/\.xml\.h/;
        s/\.oaf\.in$/\.oaf\.in\.h/;
        print OUTFILE $_;        
    }
    close OUTFILE;
    close INFILE;

    $GETTEXT ="xgettext --default-domain\=$PACKAGE --directory\=\.\."
             ." --add-comments --keyword\=\_ --keyword\=N\_"
             ." --files-from\=\.\/POTFILES\.in ";  
    $GTEST   ="test \! -f $PACKAGE\.po \|\| \( rm -f \.\/$PACKAGE\.pot "
             ."&& mv $PACKAGE\.po \.\/$PACKAGE\.pot \)";

    system($GETTEXT);
    system($GTEST);
    print "Wrote $PACKAGE.pot\n";
    system("mv POTFILES.in.old POTFILES.in");

    print "Removing generated header (.h) files...";

    open FILE, "<POTFILES.in";
    while (<FILE>) 
    {
        # Delete header files coming from xml files
        #------------------------------------------
        if ($_=~ /(.*)(\.xml)/o)
        {
            $filename = "../$1.xml.h";
            unlink($filename);
        }

        # Delete header files coming from glade files
        #--------------------------------------------
        elsif ($_=~ /(.*)(\.glade)/o)
        {
            $filename = "../$1.glade.h";
            unlink($filename);
        }

        # Delete header files coming from oaf files
        #--------------------------------------------
        elsif ($_=~ /(.*)(\.oaf\.in)/o)
        {
            $filename = "../$1.oaf.in.h";
            unlink($filename);
        }
    }
    close FILE;
    print "done\n";
}

sub merging
{
    if ($ARGV[1]){
        $LANG   = $ARGV[1]; 
    } else {
	$LANG   = $ARGV[0];
    }

    if ($ARGV[0] ne "--dist" && $ARGV[0] ne "-D") {
        print "Merging $LANG.po with $PACKAGE.pot...";
    }

    &perform_merge($LANG);
}

sub perform_merge
{
    my ($LANG) = @_;

    $MERGE="cp $LANG.po $LANG.po.old && msgmerge $LANG.po.old $PACKAGE.pot -o $LANG.po";

    system($MERGE);
    
    ## Remove the "messages" trash file generated
    ## by gettext, aswell as the backup file
    unlink "messages";
    unlink "$LANG.po.old";
}

sub not_existing
{
    ## Report error if supplied language file is non-existing
    print "${PROGRAM}:  sorry, $LANG.po does not exist!\n";
    print "Try `${PROGRAM} --help' for more information.\n";    
    exit;
}

sub gather_po_files 
{
    my @po_files = glob("./*.po");

    @languages = map (&po_file2lang, @po_files);

    foreach my $lang (@languages) {
	$po_files_by_lang{$lang} = shift (@po_files);
    }
}

sub po_file2lang 
{ 
    my $tmp = $_; 
    $tmp =~ s/^.*\/(.*)\.po$/$1/; 
    return $tmp; 
}

sub status 
{
    $exec_status="msgfmt --statistics $LANG.po";
    
    system($exec_status);
    print "\n";   
}

sub show_status 
{
    &gen_headers;
    &generate_pot;
    &gather_po_files;

    foreach my $lang (@languages){
	print "$lang: ";
	&perform_merge($lang);
    }
  
    print "\n\n * Current translation support in $PACKAGE \n\n";

    foreach my $lang (@languages){
        print "$lang: ";
	$exec_status="msgfmt --statistics $lang.po";
	system($exec_status);
    }  
}    

sub find_package_name 
{
    my $base_dirname = `pwd`;
    $base_dirname =~ s%.*/%%;
    chomp $base_dirname;

    my $conf_in = "";

    if ($base_dirname eq "po") {
        if (-f "../configure.in") {
            $conf_in = "../configure.in";
        } else {
            my $srcdir = `grep '^top_srcdir[ \t]*=' ./Makefile`;
            $srcdir =~ s/top_srcdir[ \t]*=[ \t]*([^ \t\n\r]*)/$1/;
            chomp $srcdir;
            $conf_in = "${srcdir}" . "/configure.in" . "\n";
        }

        my $conf_source; {
           local (*IN);
           local $/; # slurp mode
           open (IN, "<$conf_in") || die "can't open $conf_in: $!";
           $conf_source = <IN>;
        }

        if ($conf_source =~ /AM_INIT_AUTOMAKE\(([^,]*),(.*)/) {
            $package_name = $1;
            if ($package_name =~ /^[\$](.*)/){
                if ($conf_source =~ /$1=(.*)/) {
                    $package_name = $1;
                }
            }
        }
        return $package_name;
    }
    
    print "$PROGRAM: Unable to determine package name.\n" .  
	  "Make sure to run this script inside the po directory.\n";
    exit;
}
